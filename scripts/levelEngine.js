// backend/scripts/levelEngine.js
// Level income distribution (FINAL plan)
// - Levels 1..10 get 0.5% BV each
// - Called as: await distributeLevelIncome(purchaserId, bvAmount, opts)
// - Assumptions: User model has 'sponsor' (ObjectId), Wallet & Transaction models exist.

import mongoose from "mongoose";
import User from "../models/User.js";
import Wallet from "../models/Wallet.js";
import Transaction from "../models/Transaction.js";
import LevelIncome from "../models/LevelIncome.js"; // optional ledger for level incomes

const LEVELS = 10;
const LEVEL_PERCENT = 0.005; // 0.5% = 0.005
const SAFE_MIN = 0.000001;

/**
 * distributeLevelIncome
 * Distribute BV-based level income up to 10 upline levels.
 * @param {String|ObjectId} purchaserId  - the user whose repurchase generated BV
 * @param {Number} bvAmount              - BV amount generated by the purchase (positive)
 * @param {Object} opts                  - optional { note }
 */
export async function distributeLevelIncome(purchaserId, bvAmount, opts = {}) {
  if (!purchaserId) throw new Error("distributeLevelIncome: missing purchaserId");
  if (!bvAmount || typeof bvAmount !== "number" || bvAmount <= SAFE_MIN) return { status: true, distributed: 0 };

  // Fetch purchaser to start upline traversal
  const purchaser = await User.findById(purchaserId).lean();
  if (!purchaser) return { status: false, error: "purchaser not found" };

  let currentSponsorId = purchaser.sponsor || null;
  const payouts = [];
  let level = 1;

  // We will open a session per payout batch to ensure wallet + transaction atomic for each recipient.
  // (Could also use single transaction for whole run; per-recipient transaction reduces lock time.)
  while (level <= LEVELS && currentSponsorId) {
    const sponsor = await User.findById(currentSponsorId);
    if (!sponsor) {
      // move up if sponsor record missing
      currentSponsorId = sponsor ? sponsor.sponsor : null;
      level++;
      continue;
    }

    // Calculate payout for this level
    const payoutAmount = +(bvAmount * LEVEL_PERCENT).toFixed(2); // round to 2 decimals
    if (payoutAmount > SAFE_MIN) {
      const session = await mongoose.startSession();
      session.startTransaction();
      try {
        // credit wallet
        await Wallet.updateOne(
          { user: sponsor._id },
          { $inc: { balance: payoutAmount } },
          { upsert: true, session }
        );

        // create transaction ledger
        const tx = await Transaction.create(
          [
            {
              user: sponsor._id,
              type: "level_income",
              level,
              amount: payoutAmount,
              meta: { from: purchaserId, bv: bvAmount, note: opts.note || null },
              createdAt: new Date()
            }
          ],
          { session }
        );

        // optional LevelIncome ledger entry for reporting
        try {
          await LevelIncome.create(
            [
              {
                user: sponsor._id,
                fromUser: purchaserId,
                level,
                bvBase: bvAmount,
                amount: payoutAmount,
                note: opts.note || null,
                createdAt: new Date()
              }
            ],
            { session }
          );
        } catch (e) {
          // non-fatal: if model missing, continue (we don't abort whole transaction)
        }

        await session.commitTransaction();
        session.endSession();

        payouts.push({ userId: sponsor._id.toString(), level, amount: payoutAmount });
      } catch (err) {
        await session.abortTransaction();
        session.endSession();
        console.error("distributeLevelIncome: payout failed for sponsor", sponsor._id, err);
        // continue to next level without throwing to avoid stopping whole distribution
      }
    }

    // move one level up
    currentSponsorId = sponsor.sponsor || null;
    level++;
  } // end while

  return { status: true, distributed: payouts.length, payouts };
}

/**
 * Utility: compute potential level payout for a given BV (no DB ops)
 * @param {Number} bvAmount
 * @returns {Array} list of { level, amount }
 */
export function computeLevelPayouts(bvAmount) {
  if (!bvAmount || typeof bvAmount !== "number") return [];
  const out = [];
  for (let i = 1; i <= LEVELS; i++) out.push({ level: i, amount: +(bvAmount * LEVEL_PERCENT).toFixed(2) });
  return out;
}

export default { distributeLevelIncome, computeLevelPayouts };
